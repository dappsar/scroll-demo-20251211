import { keccak256, stringToBytes } from "viem"
import { log } from "./ui"

/**
 * IMPORTANT:
 * This redirectUri MUST match exactly one of the
 * "Authorized redirect URIs" in your Google OAuth client.
 *
 * For Vite dev:
 *   http://localhost:5173/
 */
const REDIRECT_URI = "http://localhost:5173/"

/**
 * Starts Google OAuth implicit flow to get an ID token.
 * Uses response_type=id_token and redirects back to REDIRECT_URI.
 */
export function startGoogleLogin() {
  const clientId = import.meta.env.VITE_GOOGLE_CLIENT_ID

  const scope = encodeURIComponent("openid email profile")
  const state = Math.random().toString(36).slice(2)
  const nonce = Math.random().toString(36).slice(2)

  const authUrl =
    "https://accounts.google.com/o/oauth2/v2/auth" +
    `?response_type=id_token` +
    `&client_id=${encodeURIComponent(clientId)}` +
    `&redirect_uri=${encodeURIComponent(REDIRECT_URI)}` +
    `&scope=${scope}` +
    `&state=${state}` +
    `&nonce=${nonce}` +
    `&prompt=select_account`

  log(`Redirecting to Google... redirect_uri=${REDIRECT_URI}`)
  window.location.href = authUrl
}

/**
 * WARNING: Demo-only private key derivation.
 *
 * This function extracts the `sub` field from a Google ID token
 * and deterministically derives a private key from it.
 *
 * This is acceptable ONLY for demos and workshops because:
 *   - The `sub` value is a PUBLIC identifier of the user.
 *   - Anyone who knows the `sub` can reproduce the same private key.
 *   - Therefore this MUST NOT be used in production.
 *
 * Secure production alternatives include:
 *   1. WebAuthn / Passkeys:
 *      Use hardware-backed key pairs generated by the browser.
 *
 *   2. MPC / Custodial Key Providers (Web3Auth, Privy, Turnkey, Lit, Magic):
 *      Social login maps to a secure, non-extractable private key generated by MPC,
 *      not derived from public fields like `sub`.
 *
 *   3. Locally generated entropy:
 *      Create a high-entropy random private key client-side and store it encrypted.
 *
 * If you are reading this because you're preparing a real product:
 * stop using `sub` as entropy. It is not cryptographically safe.
 */
export function extractPkFromGoogleRedirect(): `0x${string}` | null {
  // We expect to land at REDIRECT_URI with a hash fragment.
  if (`${window.location.origin}/` !== REDIRECT_URI) {
    log(
      `Current origin (${window.location.origin}/) does not match REDIRECT_URI (${REDIRECT_URI}).`
    )
  }

  const rawHash = window.location.hash
  if (!rawHash || rawHash.length <= 1) return null

  const hash = rawHash.startsWith("#") ? rawHash.slice(1) : rawHash
  const params = new URLSearchParams(hash)
  const idToken = params.get("id_token")

  if (!idToken) return null

  log("Received id_token from Google. Deriving owner private key...")

  try {
    const payloadBase64 = idToken.split(".")[1]
    const padded = payloadBase64.padEnd(
      payloadBase64.length + ((4 - (payloadBase64.length % 4)) % 4),
      "="
    )
    const json = atob(padded)
    const payload = JSON.parse(json)

    // SUB = The unique ID of the user's Google Account
    const sub: string = payload.sub
    if (!sub) throw new Error("Missing 'sub' in Google token payload")

    // Store sub as demo UUID for the smart account factory.
    try {
      localStorage.setItem("aa-uuid", sub)
    } catch {
      // ignore storage errors in demo
    }

    // WARNING: Demo-only private key derivation.
    const seed = keccak256(stringToBytes(sub)) // 32 bytes, hex
    const pk = seed as `0x${string}`

    // Clean URL (remove hash)
    window.history.replaceState(null, document.title, window.location.pathname)

    return pk
  } catch (err) {
    console.error("Failed to parse Google id_token:", err)
    log("Error parsing id_token from Google.")
    return null
  }
}
